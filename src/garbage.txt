    // --tests--
    // let t0 = SystemTimer::unit_value(Unit::Unit0);
    // my_display.qspi_fill_solid(Rgb565::RED);
    // let t1 = SystemTimer::unit_value(Unit::Unit0);
    // esp_println::println!("Initial fill blue: {} us", to_us(t0, t1));

    // let t0 = SystemTimer::unit_value(Unit::Unit0);
    // my_display.clear(Rgb565::BLUE).ok();
    // let t1 = SystemTimer::unit_value(Unit::Unit0);
    // esp_println::println!("Initial clear blue: {} us", to_us(t0, t1));
    // // Quad fill rect test: centered white box (200x200)
    // let rect_w = 199;
    // let rect_h = 199;
    // let rect_x = (466 - rect_w) / 2;
    // let rect_y = (466 - rect_h) / 2;
    // let t0 = SystemTimer::unit_value(Unit::Unit0);
    // my_display.fill_rect_solid(rect_x as u16, rect_y as u16, rect_w as u16, rect_h as u16, Rgb565::WHITE).ok();
    // let t1 = SystemTimer::unit_value(Unit::Unit0);
    // esp_println::println!("Quad fill_rect_solid 200x200: {} us", to_us(t0, t1));

    //-- other tests --

    use embedded_graphics::{
    prelude::*,
    primitives::{Rectangle, Circle, Line, PrimitiveStyle, PrimitiveStyleBuilder},
    mono_font::{ascii::FONT_6X10, MonoTextStyle},
    text::{Text, Alignment},
    };

    use embedded_graphics::Pixel;

   


    use miniz_oxide::inflate::decompress_to_vec_zlib_with_limit;
    use embedded_graphics::image::{ImageRawBE, Image};
    use embedded_graphics::prelude::*;
    use esp_hal::timer::systimer::{SystemTimer, Unit};
    use esp32s3_tests::ui::draw_image_bytes;
    
    // Helper: ticks -> microseconds
    let ticks_per_s = SystemTimer::ticks_per_second() as u64;
    let to_us = |t0: u64, t1: u64| -> u64 {
        let dt = t1.saturating_sub(t0);
        (dt.saturating_mul(1_000_000)) / ticks_per_s
    };

    let tb0 = SystemTimer::unit_value(Unit::Unit0);
    my_display.clear(Rgb565::RED).ok();
    let tb1 = SystemTimer::unit_value(Unit::Unit0);
    esp_println::println!("Clear: {} us", to_us(tb0, tb1));

    

    const W: u32 = 466;
    const H: u32 = 466;
    let bytes1: u64 = (W as u64) * (H as u64) * 2;

    // // --- Image 1 ---
    // let t0 = SystemTimer::unit_value(Unit::Unit0);

    // let z1: &[u8] = include_bytes!("../assets/alien2_466x466_rgb565_be.raw.zlib");
    // let raw1 = decompress_to_vec_zlib_with_limit(z1, (W * H * 2) as usize).unwrap_or_default();

    // let t1 = SystemTimer::unit_value(Unit::Unit0);

    // if raw1.len() == (W * H * 2) as usize {
    //     // Draw (embedded-graphics will prefer fill_contiguous)
    //     let raw_img: ImageRawBE<Rgb565> = ImageRawBE::new(&raw1, W);
    //     let _ = Image::new(&raw_img, Point::new(0, 0)).draw(&mut my_display);
    //     // // Direct one-shot blit without building a scratch Vec or using e-g.
    // }

    // let t2 = SystemTimer::unit_value(Unit::Unit0);

    // let decomp_us1 = to_us(t0, t1);
    // let draw_us1   = to_us(t1, t2);
    // let kbps1 = (bytes1.saturating_mul(1_000_000) / draw_us1) / 1024;

    // esp_println::println!(
    //     "Image1 (ImageRawBE), data size {} decompress: {} us, draw: {} us ({} KiB/s)",
    //     bytes1, decomp_us1, draw_us1, kbps1
    // );


    // --- Image 3: blit_rect_be_fast (alien4) ---
    let t6 = SystemTimer::unit_value(Unit::Unit0);

    let z3: &[u8] = include_bytes!("../assets/alien4_466x466_rgb565_be.raw.zlib");
    let raw3 = decompress_to_vec_zlib_with_limit(z3, (W * H * 2) as usize).unwrap_or_default();

    let t7 = SystemTimer::unit_value(Unit::Unit0);

    if raw3.len() == (W * H * 2) as usize {
        // Full-screen rect at (0,0). Change x,y,w,h to test sub-rect throughput.
        let _ = my_display.blit_rect_be_fast(0, 0, W as u16, H as u16, &raw3);
    }

    let t8 = SystemTimer::unit_value(Unit::Unit0);

    let decomp_us3 = to_us(t6, t7);
    let draw_us3   = to_us(t7, t8);
    let kbps3 = (bytes1.saturating_mul(1_000_000) / draw_us3) / 1024;

    esp_println::println!(
        "Image3 (blit_rect_be_fast), data size {} decompress: {} us, draw: {} us ({} KiB/s)",
        bytes1, decomp_us3, draw_us3, kbps3
    );

    
    const IMG_W_OP: u32 = 308;
    const IMG_H_OP: u32 = 374;

    let t0 = SystemTimer::unit_value(Unit::Unit0);
    // Raw (uncompressed) big-endian RGB565: length must be 240*240*2 = 115200 bytes
    let alien8: &[u8] = include_bytes!("../assets/alien1_308x374_rgb565_be.raw");

    if alien8.len() == (IMG_W_OP * IMG_H_OP * 2) as usize {
        // This helper centers automatically
        draw_image_bytes(&mut my_display, alien8, IMG_W_OP, IMG_H_OP, false);
        let t1 = SystemTimer::unit_value(Unit::Unit0);
        esp_println::println!("Alien8 draw time: {} us", to_us(t0, t1));
    } else {
        esp_println::println!("alien8 size mismatch: {}", alien8.len());
    }



    // Draw a red border rectangle and time it too
    let w: u32 = 200;
    let h: u32 = 200;
    let w2: u32 = w/2;
    let h2: u32 = h/2;
    let border_style = PrimitiveStyle::with_stroke(Rgb565::RED, 1);
    let tb0 = SystemTimer::unit_value(Unit::Unit0);

    Rectangle::new(Point::new((233 - (w/2)) as i32, (233 - (h/2)) as i32), Size::new(w, h))
        .into_styled(border_style)
        .draw(&mut my_display)
        .ok();
    let tb1 = SystemTimer::unit_value(Unit::Unit0);
    Rectangle::new(Point::new((233 - (w/2)) as i32, (233 - (h/2)) as i32), Size::new(w2, h2))
        .into_styled(border_style)
        .draw(&mut my_display)
        .ok();

    let tb2 = SystemTimer::unit_value(Unit::Unit0);

    esp_println::println!(
        "Border draw: {} us, upload: {} us",
        to_us(tb0, tb1),
        to_us(tb1, tb2)
    );

    use embedded_graphics::mono_font::ascii::FONT_10X20;
    use embedded_graphics::mono_font::MonoTextStyleBuilder;

    let style = MonoTextStyleBuilder::new()
        .font(&FONT_10X20)
        .text_color(Rgb565::WHITE)
        .background_color(Rgb565::BLACK)
        .build();

    // Circle params
    let cx: i32 = 233;
    let cy: i32 = 233;
    let radius: i32 = 233;
    let margin: i32 = 20; // inward padding from edge
    // Diagonal offset (≈ 45°) staying inside circle
    let diag: i32 = (((radius - margin) as f32) * 0.7071) as i32;

    // Cardinal + diagonal positions (all inside circle)
    let samples = [
        ("CENTER", cx, cy),
        ("TOP",    cx, cy - (radius - margin)),
        ("BOTTOM", cx, cy + (radius - margin)),
        ("LEFT",   cx - (radius - margin), cy),
        ("RIGHT",  cx + (radius - margin), cy),
        ("NW",     cx - diag, cy - diag),
        ("NE",     cx + diag, cy - diag),
        ("SW",     cx - diag, cy + diag),
        ("SE",     cx + diag, cy + diag),
    ];

    // // Optional: draw circle outline for reference
    // let t0 = SystemTimer::unit_value(Unit::Unit0);
    // let _ = Circle::new(Point::new(0, 0), (radius as u32) * 2)
    //     .into_styled(PrimitiveStyle::with_stroke(Rgb565::BLUE, 1))
    //     .draw(&mut my_display);
    // let t1 = SystemTimer::unit_value(Unit::Unit0);
    // esp_println::println!("Circle outline draw: {} us", to_us(t0, t1));

    for (label, x, y) in samples {
        // Skip if outside square bounds (defensive)
        if x < 0 || y < 0 || x >= 466 || y >= 466 { continue; }

        // Center alignment keeps label centered on (x,y)
        let t0 = SystemTimer::unit_value(Unit::Unit0);
        let _ = Text::with_alignment(label, Point::new(x, y), style, Alignment::Center)
            .draw(&mut my_display);
        let t1 = SystemTimer::unit_value(Unit::Unit0);
        esp_println::println!("Text '{}' draw: {} us @ ({},{})", label, to_us(t0, t1), x, y);
    }


    
